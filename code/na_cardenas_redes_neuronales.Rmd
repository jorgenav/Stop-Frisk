---
title: "Redes neuronales"
author: "Nathaly"
date: "20 de junio de 2017"
output: html_document
---
#https://www.r-bloggers.com/multilabel-classification-with-neuralnet-package/
## 1. Carga de librerías
```{r, message=FALSE}
library(dplyr)
library(ade4)
library(nnet)
library(neuralnet)
library(caret)
library(ROCR)
```


## 2. Cargar datos

```{r,message=FALSE}
# Carga del Dataset
source('Cleaning_Data.R')
dim(SQFdata)
```

## 3 Transformación de variables

### 3.1 Creación de dataset transformado

```{r}
SQFdata_modif <- SQFdata
```

### 3.2 Eliminación de variables

```{r}
#
# Eliminación de variables con más de ~60% de datos faltantes.
#
SQFdata_modif <- SQFdata_modif %>%
                    select(-c(arstoffn, sumoffen, officrid, offverb, offshld,
                              forceuse, othfeatr, addrnum, stname, beat,
                              post, state, zip, rescode, premtype, aptnum))


#
# Eliminación de variables con poca o nula varianza (casos pertenecientes
# todos a una misma clase). 7 variables eliminadas
#
SQFdata_modif <- SQFdata_modif %>%
                    select(-c(adtlrept, riflshot, asltweap, machgun,
                             pf_baton, pf_pepsp, addrtyp, year,
                             compyear, comppct, lineCM, dob, dettypCM))



# 
# Eliminación de variables con demasiados niveles (strings). 8 variables eliminadas
# 
SQFdata_modif <- SQFdata_modif %>%
                    select(-c(premname, stinter, crossst, sector,
                              pct, crimsusp, addrpct, detailCM))

# 
# Variables asociadas a series temporales o coordenadas -> No son de interés para
# el problema que ocupa
# 
SQFdata_modif <- SQFdata_modif %>%
                    select(-c(datestop, timestop, xcoord, ycoord))



# 
# Número de variables final
# 
dim(SQFdata)
dim(SQFdata_modif)
```

### 3.3 Tratamiento de NAs

```{r}
# 
# Eliminación de NAs en variable age
#
SQFdata_modif <- SQFdata_modif %>% filter(!is.na(age))



# 
# Modificación de variables no eliminadas
# 

# Uso de armas
SQFdata_modif$pistol[which(is.na(SQFdata_modif$pistol))]     <- 'N'
SQFdata_modif$knifcuti[which(is.na(SQFdata_modif$knifcuti))] <- 'N'
SQFdata_modif$othrweap[which(is.na(SQFdata_modif$othrweap))] <- 'N'

# Uso de fuerza física
SQFdata_modif$pf_hands[which(is.na(SQFdata_modif$pf_hands))] <- 'N'
SQFdata_modif$pf_wall[which(is.na(SQFdata_modif$pf_wall))]   <- 'N'
SQFdata_modif$pf_grnd[which(is.na(SQFdata_modif$pf_grnd))]   <- 'N'
SQFdata_modif$pf_drwep[which(is.na(SQFdata_modif$pf_drwep))] <- 'N'
SQFdata_modif$pf_ptwep[which(is.na(SQFdata_modif$pf_ptwep))] <- 'N'
SQFdata_modif$pf_hcuff[which(is.na(SQFdata_modif$pf_hcuff))] <- 'N'
SQFdata_modif$pf_other[which(is.na(SQFdata_modif$pf_other))] <- 'N'

# Circunstancias adicionales
SQFdata_modif$ac_rept[which(is.na(SQFdata_modif$ac_rept))]   <- 'N'
SQFdata_modif$ac_inves[which(is.na(SQFdata_modif$ac_inves))] <- 'N'
SQFdata_modif$ac_proxm[which(is.na(SQFdata_modif$ac_proxm))] <- 'N'
SQFdata_modif$ac_incid[which(is.na(SQFdata_modif$ac_incid))] <- 'N'
SQFdata_modif$ac_time[which(is.na(SQFdata_modif$ac_time))]   <- 'N'
SQFdata_modif$ac_evasv[which(is.na(SQFdata_modif$ac_evasv))] <- 'N'
SQFdata_modif$ac_assoc[which(is.na(SQFdata_modif$ac_assoc))] <- 'N'
SQFdata_modif$ac_cgdir[which(is.na(SQFdata_modif$ac_cgdir))] <- 'N'
SQFdata_modif$ac_stsnd[which(is.na(SQFdata_modif$ac_stsnd))] <- 'N'
SQFdata_modif$ac_other[which(is.na(SQFdata_modif$ac_other))] <- 'N'

# Razones para el cacheo
SQFdata_modif$rf_vcrim[which(is.na(SQFdata_modif$rf_vcrim))] <- 'N'
SQFdata_modif$rf_othsw[which(is.na(SQFdata_modif$rf_othsw))] <- 'N'
SQFdata_modif$rf_attir[which(is.na(SQFdata_modif$rf_attir))] <- 'N'
SQFdata_modif$rf_vcact[which(is.na(SQFdata_modif$rf_vcact))] <- 'N'
SQFdata_modif$rf_rfcmp[which(is.na(SQFdata_modif$rf_rfcmp))] <- 'N'
SQFdata_modif$rf_furt[which(is.na(SQFdata_modif$rf_furt))]   <- 'N'
SQFdata_modif$rf_bulg[which(is.na(SQFdata_modif$rf_bulg))]   <- 'N'
SQFdata_modif$rf_verbl[which(is.na(SQFdata_modif$rf_verbl))] <- 'N'
SQFdata_modif$rf_knowl[which(is.na(SQFdata_modif$rf_knowl))] <- 'N'

# Razones para la detención
SQFdata_modif$cs_objcs[which(is.na(SQFdata_modif$cs_objcs))] <- 'N'
SQFdata_modif$cs_descr[which(is.na(SQFdata_modif$cs_descr))] <- 'N'
SQFdata_modif$cs_casng[which(is.na(SQFdata_modif$cs_casng))] <- 'N'
SQFdata_modif$cs_lkout[which(is.na(SQFdata_modif$cs_lkout))] <- 'N'
SQFdata_modif$cs_cloth[which(is.na(SQFdata_modif$cs_cloth))] <- 'N'
SQFdata_modif$cs_drgtr[which(is.na(SQFdata_modif$cs_drgtr))] <- 'N'
SQFdata_modif$cs_furtv[which(is.na(SQFdata_modif$cs_furtv))] <- 'N'
SQFdata_modif$cs_vcrim[which(is.na(SQFdata_modif$cs_vcrim))] <- 'N'
SQFdata_modif$cs_bulge[which(is.na(SQFdata_modif$cs_bulge))] <- 'N'
SQFdata_modif$cs_other[which(is.na(SQFdata_modif$cs_other))] <- 'N'

# Motivos de búsqueda
SQFdata_modif$sb_hdobj[which(is.na(SQFdata_modif$sb_hdobj))] <- 'N'
SQFdata_modif$sb_outln[which(is.na(SQFdata_modif$sb_outln))] <- 'N'
SQFdata_modif$sb_admis[which(is.na(SQFdata_modif$sb_admis))] <- 'N'
SQFdata_modif$sb_other[which(is.na(SQFdata_modif$sb_other))] <- 'N'

# Comprobación de NAs
sum(is.na(SQFdata))
sum(is.na(SQFdata_modif))
```

### 3.4 Eliminación de variables con varianza nula

```{r}
# 
# Con caret::nearZeroVar se elimina el resto de variables que presentan varianza
# nula después de aplicar la imputación de NAs
#
SQFdata_modif <- SQFdata_modif[-nearZeroVar(SQFdata_modif)]

dim(SQFdata)
dim(SQFdata_modif)
```

### 3.5 Eliminación de variables relacionadas con el registro

```{r}
SQFdata_modif <- SQFdata_modif[,-c(1,2,41,42,50) ]
```



### 3.6 Variables numéricas
```{r}
SQFdata_modif.num <- SQFdata_modif[,sapply(SQFdata_modif, is.numeric)]
```


### 3.7 Variables dummies 

```{r}
SQFdata_modif.cat <- SQFdata_modif[,sapply(SQFdata_modif, is.factor)]


# binarización factores con dos niveles
SQFdata_modif.cat1<- SQFdata_modif.cat[, sapply(SQFdata_modif.cat, function(col) length(unique(col))) < 3]

YesNoCat <- sapply(SQFdata_modif.cat1,
                   function(x) (levels(x) == c("Y","N")) || (levels(x) == c("N","Y")))
SQFdata_modif.cat1[YesNoCat] <- sapply(SQFdata_modif.cat1[YesNoCat], function(x) ifelse(x=="Y",1,0))

SQFdata_modif.cat1$inout<- as.numeric(SQFdata_modif.cat1$inout)
SQFdata_modif.cat1$inout[SQFdata_modif.cat1$inout==2] <- 0


# binarización factores con más de dos niveles
SQFdata_modif.cat2 <- SQFdata_modif.cat[, sapply(SQFdata_modif.cat, function(col) length(unique(col))) > 2]
SQFdata_modif.cat2 <- acm.disjonctif(SQFdata_modif.cat2) 

```


## 4. Redes neuronales
### 4.1 Redes neuronales solo variables numéricas
```{r}
maxs <- apply(SQFdata_modif.num , 2, max) 
mins <- apply(SQFdata_modif.num , 2, min)

scaled <- as.data.frame(scale(SQFdata_modif.num , center = mins, scale = maxs - mins))

SQFdata_modif.num.y <- cbind(scaled, as.factor(SQFdata_modif$arstmade))

n.num       <- nrow(SQFdata_modif.num.y)
muestra.num <- sample(n.num,n.num*.70)
train.num   <- SQFdata_modif.num.y[muestra.num, ]
test.num    <- SQFdata_modif.num.y[-muestra.num, ]

n  <- names(train.num)
f.num  <- arrestado + no.arrestado ~ perobs + perstop + repcmd + revcmd + 
    age + ht_feet + ht_inch + weight
nn.num <- neuralnet(f.num, data=train.num,hidden=2,linear.output=F, threshold=0.01, rep=3)


```

#### 4.1.2 Predicción
```{r, message= FALSE}
predict.num <- compute(nn, test[-5])$net.result

maxidx <- function(cat) {
    return(which(cat == max(cat)))
}
idx <- apply(predic.num, c(1), maxidx)

prediction <- c('arrestado', 'no,arrestado')[idx]
table(prediction, iris$Species)

```

#### 4.1.3 Validación

```{r}
confusionMatrix(data=factor(pred.cat.level),
                reference=factor(test$arstmade),
                positive='1')

nn.pred <- prediction(pred.cat$net.result, test$arstmade)
pred_tpr_fpr <- performance(nn.pred, measure = "tpr", x.measure = "fpr")
plot(pred_tpr_fpr, main = "ROC curve", col = "blue", lwd = 3)
auc <- performance(nn.pred, measure = "auc")
auc <- auc@y.values[[1]]
auc

```

### 4.2 Redes neuronales solo variables categóricas
```{r}
SQFdata_modif.cat  <- data.frame(SQFdata_modif.cat1,SQFdata_modif.cat2)

nfilas    <- nrow(SQFdata_modif.cat)
muestra   <- sample(nfilas, nfilas*.70)
train     <- SQFdata_modif.cat[muestra, ]
test      <- SQFdata_modif.cat[-muestra, ]

n  <- names(train)
f  <- as.formula(paste("arstmade ~", paste(n[!n %in% "arstmade"], collapse = " + ")))
nn <- neuralnet(f,data=train,hidden=14,linear.output=F, err.fct="ce", act.fct = "logistic",
                threshold=0.01, rep=3)
#stepmax=1e6
```


#### 4.2.2 Predicción
```{r, message= FALSE}
pred.cat <-compute(nn, test[,-4])
pred.cat.level  <- ifelse(pred.cat$net.result >0.1283,1,0)

```

#### 4.2.3 Validación

```{r}
confusionMatrix(data=factor(pred.cat.level),
                reference=factor(test$arstmade),
                positive='1')

nn.pred <- prediction(pred.cat$net.result, test$arstmade)
pred_tpr_fpr <- performance(nn.pred, measure = "tpr", x.measure = "fpr")
plot(pred_tpr_fpr, main = "ROC curve", col = "blue", lwd = 3)
auc <- performance(nn.pred, measure = "auc")
auc <- auc@y.values[[1]]
auc

```


### caret
```{r}
parametros <- train(as.factor(arstmade)~., data=train, method="nnet",tuneLength=2, trace=F, maxit=2000)
# preProcess="range"
size <- parametros$bestTune$size
decay <- parametros$bestTune$decay
predict.nn <- predict(parametros, test[,-3])

confusionMatrix(predict.nn,
                reference= test$arstmade,
                positive='1')
```

### Redes neuronales todas las variables
```{r}
SQFdata_modif.num.cat <- data.frame(SQFdata_modif.cat1,SQFdata_modif.cat2, SQFdata_modif.num)
```

